(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['vue-leaflet'] = {}, global.vue));
}(this, (function (exports, vue) { 'use strict';

  const props = {
    position: {
      type: String,
      default: "topright",
    },
  };
  const setup = (leafletRef) => {
    vue.onUnmounted(() => {
      if (leafletRef.value) {
        leafletRef.value.remove();
      }
    });
  };

  const props$1 = {
    ...props,
    collapsed: {
      type: Boolean,
      default: true,
    },
    autoZIndex: {
      type: Boolean,
      default: true,
    },
    hideSingleBase: {
      type: Boolean,
      default: false,
    },
    sortLayers: {
      type: Boolean,
      default: false,
    },
    sortFunction: {
      type: Function,
      default: undefined,
    },
  };

  const setup$1 = (props, leafletRef) => {
    setup(leafletRef);
    const options = {
      collapsed: props.collapsed,
      autoZIndex: props.autoZIndex,
      hideSingleBase: props.hideSingleBase,
      sortLayers: props.sortLayers,
      sortFunction: props.sortFunction,
    };

    const methods = {
      addLayer(layer) {
        if (layer.layerType === "base") {
          leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);
        } else if (layer.layerType === "overlay") {
          leafletRef.value.addOverlay(layer.leafletObject, layer.name);
        }
      },
      removeLayer(layer) {
        leafletRef.value.removeLayer(layer.leafletObject);
      },
    };
    return { options, methods };
  };

  const debounce = (fn, time) => {
    let timeout;

    return function (...args) {
      const context = this;
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(() => {
        fn.apply(context, args);
        timeout = null;
      }, time);
    };
  };

  const capitalizeFirstLetter = (string) => {
    if (!string || typeof string.charAt !== "function") {
      return string;
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  };

  const propsBinder = (methods, leafletElement, props, setOptions) => {
    for (const key in props) {
      const setMethodName = "set" + capitalizeFirstLetter(key);
      if (methods[setMethodName]) {
        vue.watch(
          () => props[key],
          (newVal, oldVal) => {
            methods[setMethodName](newVal, oldVal);
          }
        );
      } else if (setMethodName === "setOptions") {
        vue.watch(
          () => props[key],
          (newVal) => {
            setOptions(leafletElement, newVal);
          }
        );
      } else if (leafletElement[setMethodName]) {
        vue.watch(
          () => props[key],
          (newVal) => {
            leafletElement[setMethodName](newVal);
          }
        );
      }
    }
  };

  const remapEvents = (contextAttrs) => {
    const result = {};
    for (const attrName in contextAttrs) {
      if (attrName.startsWith("on") && !attrName.startsWith("onUpdate")) {
        const eventName = attrName.slice(2).toLocaleLowerCase();
        result[eventName] = contextAttrs[attrName];
      }
    }
    return result;
  };

  const resetWebpackIcon = (Icon) => {
    delete Icon.Default.prototype._getIconUrl;

    Icon.Default.mergeOptions({
      iconRetinaUrl: require("leaflet/dist/images/marker-icon-2x.png"),
      iconUrl: require("leaflet/dist/images/marker-icon.png"),
      shadowUrl: require("leaflet/dist/images/marker-shadow.png"),
    });
  };

  /**
   * Wraps a placeholder function and provides it with the given name.
   * The wrapper can later be updated with {@link updateLeafletWrapper}
   * to provide a different function.
   *
   * @param {String} methodName Key used to provide the wrapper function
   */
  const provideLeafletWrapper = (methodName) => {
    const wrapped = vue.ref(() =>
      console.warn(`Method ${methodName} has been invoked without being replaced`)
    );
    const wrapper = (...args) => wrapped.value(...args);
    // eslint-disable-next-line vue/no-ref-as-operand
    wrapper.wrapped = wrapped;
    vue.provide(methodName, wrapper);

    return wrapper;
  };

  /**
   * Change the function that will be executed when an injected Leaflet wrapper
   * is invoked.
   *
   * @param {*} wrapper Provided wrapper whose wrapped function is to be updated
   * @param {function} leafletMethod New method to be wrapped by the wrapper
   */
  const updateLeafletWrapper = (wrapper, leafletMethod) =>
    (wrapper.wrapped.value = leafletMethod);

  var script = {
    name: "LControlLayers",
    props: props$1,
    setup(props) {
      const leafletRef = vue.ref({});

      const registerLayerControl = vue.inject("registerLayerControl");
      const { options, methods } = setup$1(props, leafletRef);
      vue.onMounted(async () => {
        const { control, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        leafletRef.value = control.layers(null, null, options);
        propsBinder(methods, leafletRef.value, props, setOptions);

        registerLayerControl({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
      });
    },
    render() {
      return null;
    },
  };

  const render = () => {};


  script.render = render;
  script.__file = "src/components/LControlLayers.vue";

  var script$1 = {
    props: {
      /**
       * The center of the map, supports .sync modifier
       */
      center: {
        type: [Object, Array],
        default: () => [0, 0],
      },
      /**
       * The bounds of the map, supports .sync modifier
       */
      bounds: {
        type: [Array, Object],
        default: undefined,
      },
      /**
       * The max bounds of the map
       */
      maxBounds: {
        type: [Array, Object],
        default: undefined,
      },
      /**
       * The zoom of the map, supports .sync modifier
       */
      zoom: {
        type: Number,
        default: 0,
      },
      /**
       * The minZoom of the map
       */
      minZoom: {
        type: Number,
        default: undefined,
      },
      /**
       * The maxZoom of the map
       */
      maxZoom: {
        type: Number,
        default: undefined,
      },
      /**
       * The paddingBottomRight of the map
       */
      paddingBottomRight: {
        type: Array,
        default: undefined,
      },
      /**
       * The paddingTopLeft of the map
       */
      paddingTopLeft: {
        type: Array,
        default: undefined,
      },
      /**
       * The padding of the map
       */
      padding: {
        type: Array,
        default: undefined,
      },
      /**
       * The worldCopyJump option for the map
       */
      worldCopyJump: {
        type: Boolean,
        default: false,
      },
      /**
       * The crs option for the map
       * @values CRS.EPSG3857
       */
      crs: {
        type: Object,
      },
      maxBoundsViscosity: {
        type: Number,
        default: undefined,
      },
      inertia: {
        type: Boolean,
        default: undefined,
      },
      inertiaDeceleration: {
        type: Number,
        default: undefined,
      },
      inertiaMaxSpeed: {
        type: Number,
        default: undefined,
      },
      easeLinearity: {
        type: Number,
        default: undefined,
      },
      zoomAnimation: {
        type: Boolean,
        default: undefined,
      },
      zoomAnimationThreshold: {
        type: Number,
        default: undefined,
      },
      fadeAnimation: {
        type: Boolean,
        default: undefined,
      },
      markerZoomAnimation: {
        type: Boolean,
        default: undefined,
      },
      noBlockingAnimations: {
        type: Boolean,
        default: false,
      },
    },
    setup(props, context) {
      const root = vue.ref(null);
      const blueprint = vue.reactive({
        ready: false,
        leafletRef: {},
        layersToAdd: [],
        layersInControl: [],
      });

      const options = {
        minZoom: props.minZoom,
        maxZoom: props.maxZoom,
        maxBounds: props.maxBounds,
        maxBoundsViscosity: props.maxBoundsViscosity,
        worldCopyJump: props.worldCopyJump,
        crs: props.crs,
        center: props.center,
        zoom: props.zoom,
        inertia: props.inertia,
        inertiaDeceleration: props.inertiaDeceleration,
        inertiaMaxSpeed: props.inertiaMaxSpeed,
        easeLinearity: props.easeLinearity,
        zoomAnimation: props.zoomAnimation,
        zoomAnimationThreshold: props.zoomAnimationThreshold,
        fadeAnimation: props.fadeAnimation,
        markerZoomAnimation: props.markerZoomAnimation,
      };

      const addLayer = provideLeafletWrapper("addLayer");
      const removeLayer = provideLeafletWrapper("removeLayer");
      const registerLayerControl = provideLeafletWrapper("registerLayerControl");

      const eventHandlers = {
        moveEndHandler() {
          /**
           * Triggers when zoom is updated
           * @type {number,string}
           */
          context.emit("update:zoom", blueprint.leafletRef.getZoom());
          /**
           * Triggers when center is updated
           * @type {object,array}
           */
          context.emit("update:center", blueprint.leafletRef.getCenter());

          /**
           * Triggers when bounds are updated
           * @type {object}
           */
          context.emit("update:bounds", blueprint.leafletRef.getBounds());
        },
        overlayAddHandler(e) {
          const layer = blueprint.layersInControl.find((l) => l.name === e.name);
          if (layer) {
            layer.updateVisibleProp(true);
          }
        },
        overlayRemoveHandler(e) {
          const layer = blueprint.layersInControl.find((l) => l.name === e.name);
          if (layer) {
            layer.updateVisibleProp(false);
          }
        },
      };

      vue.onMounted(async () => {
        const {
          map,
          CRS,
          Icon,
          latLngBounds,
          latLng,
          DomEvent,
          setOptions,
        } = await import('leaflet/dist/leaflet-src.esm');
        resetWebpackIcon(Icon);
        options.crs = options.crs || CRS.EPSG3857;

        const methods = {
          addLayer(layer) {
            if (layer.layerType !== undefined) {
              if (blueprint.layerControl === undefined) {
                blueprint.layersToAdd.push(layer);
              } else {
                const exist = blueprint.layersInControl.find(
                  (l) =>
                    l.leafletObject._leaflet_id ===
                    layer.leafletObject._leaflet_id
                );
                if (!exist) {
                  blueprint.layerControl.addLayer(layer);
                  blueprint.layersInControl.push(layer);
                }
              }
            }
            if (layer.visible !== false) {
              blueprint.leafletRef.addLayer(layer.leafletObject);
            }
          },
          removeLayer(layer) {
            if (layer.layerType !== undefined) {
              if (blueprint.layerControl === undefined) {
                blueprint.layersToAdd = blueprint.layersToAdd.filter(
                  (l) => l.name !== layer.name
                );
              } else {
                blueprint.layerControl.removeLayer(layer.leafletObject);
                blueprint.layersInControl = blueprint.layersInControl.filter(
                  (l) =>
                    l.leafletObject._leaflet_id !==
                    layer.leafletObject._leaflet_id
                );
              }
            }
            blueprint.leafletRef.removeLayer(layer.leafletObject);
          },

          registerLayerControl(lControlLayer) {
            blueprint.layerControl = lControlLayer;
            blueprint.leafletRef.addControl(lControlLayer.leafletObject);
            blueprint.layersToAdd.forEach((layer) => {
              blueprint.layerControl.addLayer(layer);
            });
            blueprint.layersToAdd = [];
          },

          setZoom(newVal) {
            blueprint.leafletRef.setZoom(newVal, {
              animate: props.noBlockingAnimations ? false : null,
            });
          },

          setPaddingBottomRight(newVal) {
            blueprint.paddingBottomRight = newVal;
          },
          setPaddingTopLeft(newVal) {
            blueprint.paddingTopLeft = newVal;
          },
          setPadding(newVal) {
            blueprint.padding = newVal;
          },
          setCrs(newVal) {
            const prevBounds = blueprint.leafletRef.getBounds();
            blueprint.leafletRef.options.crs = newVal;
            blueprint.leafletRef.fitBounds(prevBounds, {
              animate: false,
              padding: [0, 0],
            });
          },
          fitBounds(bounds) {
            blueprint.leafletRef.fitBounds(bounds, {
              animate: this.noBlockingAnimations ? false : null,
            });
          },
          setBounds(newVal) {
            if (!newVal) {
              return;
            }
            const newBounds = latLngBounds(newVal);
            if (!newBounds.isValid()) {
              return;
            }
            const oldBounds =
              blueprint.lastSetBounds || blueprint.leafletRef.getBounds();
            const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals
            if (boundsChanged) {
              blueprint.lastSetBounds = newBounds;
              blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);
            }
          },

          setCenter(newVal) {
            if (newVal == null) {
              return;
            }
            const newCenter = latLng(newVal);
            const oldCenter =
              blueprint.lastSetCenter || blueprint.leafletRef.getCenter();
            if (
              oldCenter.lat !== newCenter.lat ||
              oldCenter.lng !== newCenter.lng
            ) {
              blueprint.lastSetCenter = newCenter;
              blueprint.leafletRef.panTo(newCenter, {
                animate: this.noBlockingAnimations ? false : null,
              });
            }
          },
        };

        updateLeafletWrapper(addLayer, methods.addLayer);
        updateLeafletWrapper(removeLayer, methods.removeLayer);
        updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);

        blueprint.leafletRef = map(root.value, options);

        propsBinder(methods, blueprint.leafletRef, props, setOptions);
        const listeners = remapEvents(context.attrs);

        blueprint.leafletRef.on(
          "moveend",
          debounce(eventHandlers.moveEndHandler, 100)
        );
        blueprint.leafletRef.on("overlayadd", eventHandlers.overlayAddHandler);
        blueprint.leafletRef.on(
          "overlayremove",
          eventHandlers.overlayRemoveHandler
        );
        DomEvent.on(blueprint.leafletRef, listeners);
        blueprint.ready = true;
        vue.nextTick(() => context.emit("ready"));
      });

      vue.onBeforeUnmount(() => {
        if (blueprint.leafletRef) {
          blueprint.leafletRef.remove();
        }
      });

      const leafletObject = vue.computed(() => blueprint.leafletRef);
      const ready = vue.computed(() => blueprint.ready);
      return { root, ready, leafletObject };
    },
  };

  const _hoisted_1 = {
    style: {"width":"100%","height":"100%"},
    ref: "root"
  };

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("div", _hoisted_1, [
      ($setup.ready)
        ? vue.renderSlot(_ctx.$slots, "default", { key: 0 })
        : vue.createCommentVNode("v-if", true)
    ], 512 /* NEED_PATCH */))
  }

  script$1.render = render$1;
  script$1.__file = "src/components/LMap.vue";

  const props$2 = {
    pane: {
      type: String,
      default: "overlayPane",
    },
    attribution: {
      type: String,
      default: null,
    },
    name: {
      type: String,
      custom: true,
      default: undefined,
    },
    layerType: {
      type: String,
      custom: true,
      default: undefined,
    },
    visible: {
      type: Boolean,
      custom: true,
      default: true,
    },
  };

  const setup$2 = (props, leafletRef, context) => {
    const addLayer = vue.inject("addLayer");
    const removeLayer = vue.inject("removeLayer");
    const options = {
      attribution: props.attribution,
      pane: props.pane,
    };

    const methods = {
      setAttribution(val, old) {
        const attributionControl = this.$parent.leafletObject.attributionControl;
        attributionControl.removeAttribution(old).addAttribution(val);
      },
      setName() {
        removeLayer(leafletRef.value);
        if (props.visible) {
          addLayer(leafletRef.value);
        }
      },
      setLayerType() {
        removeLayer(leafletRef.value);
        if (props.visible) {
          addLayer(leafletRef.value);
        }
      },
      setVisible(isVisible) {
        if (leafletRef.value) {
          if (isVisible) {
            addLayer(leafletRef.value);
          } else {
            removeLayer(leafletRef.value);
          }
        }
      },
      bindPopup({ leafletObject }) {
        leafletRef.value.bindPopup(leafletObject);
      },
      bindTooltip({ leafletObject }) {
        leafletRef.value.bindTooltip(leafletObject);
      },
      unbindTooltip() {
        const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;
        if (tooltip) {
          tooltip.unbindTooltip();
        }
      },
      unbindPopup() {
        const popup = leafletRef.value ? leafletRef.value.getPopup() : null;
        if (popup) {
          popup.unbindPopup();
        }
      },
      updateVisibleProp(value) {
        /**
         * Triggers when the visible prop needs to be updated
         * @type {boolean}
         * @property {boolean} value - value of the visible property
         */
        context.emit("update:visible", value);
      },
    };

    vue.provide("bindPopup", methods.bindPopup);
    vue.provide("bindTooltip", methods.bindTooltip);
    vue.provide("unbindTooltip", methods.unbindTooltip);
    vue.provide("unbindPopup", methods.unbindPopup);

    vue.onUnmounted(() => {
      methods.unbindPopup();
      methods.unbindTooltip();
      removeLayer({ leafletObject: leafletRef.value });
    });

    return { options, methods };
  };

  const render$2 = (ready, context) => () => {
    if (ready.value && context.slots.default) {
      return vue.h("div", { style: { display: "none" } }, context.slots.default());
    }
    return null;
  };

  const props$3 = {
    ...props$2,
    pane: {
      type: String,
      default: "markerPane",
    },
    draggable: {
      type: Boolean,
      custom: true,
      default: false,
    },
    latLng: {
      type: [Object, Array],
      custom: true,
      default: null,
    },
    icon: {
      type: [Object],
      custom: false,
    },
    zIndexOffset: {
      type: Number,
      custom: false,
      default: null,
    },
  };

  const setup$3 = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setup$2(
      props,
      leafletRef,
      context
    );
    const options = {
      ...layerOptions,
      ...props,
    };
    const latLng = vue.inject("latLng");

    const methods = {
      ...layerMethods,
      setDraggable(value) {
        if (leafletRef.value.dragging) {
          value
            ? leafletRef.value.dragging.enable()
            : leafletRef.value.dragging.disable();
        }
      },
      latLngSync(event) {
        context.emit("update:latLng", event.latlng);
        context.emit("update:lat-lng", event.latlng);
      },
      setLatLng(newVal) {
        if (newVal == null) {
          return;
        }

        if (leafletRef.value) {
          const oldLatLng = leafletRef.value.getLatLng();
          const newLatLng = latLng(newVal);
          if (
            newLatLng.lat !== oldLatLng.lat ||
            newLatLng.lng !== oldLatLng.lng
          ) {
            leafletRef.value.setLatLng(newLatLng);
          }
        }
      },
    };
    return { options, methods };
  };

  /**
   * Marker component, lets you add and personalize markers on the map
   */
  var script$2 = {
    name: "LMarker",
    props: props$3,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const addLayer = vue.inject("addLayer");

      const latLng = provideLeafletWrapper("latLng");
      vue.provide("canSetParentHtml", () => !!leafletRef.value.getElement());
      vue.provide(
        "setParentHtml",
        (html) => (leafletRef.value.getElement().innerHTML = html)
      );
      vue.provide(
        "setIcon",
        (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)
      );
      const { options, methods } = setup$3(props, leafletRef, context);

      vue.onMounted(async () => {
        const {
          marker,
          DomEvent,
          latLng: leafletLatLng,
          setOptions,
        } = await import('leaflet/dist/leaflet-src.esm');
        updateLeafletWrapper(latLng, leafletLatLng);

        leafletRef.value = marker(props.latLng, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        leafletRef.value.on("move", debounce(methods.latLngSync, 100));
        propsBinder(methods, leafletRef.value, props, setOptions);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
      });

      return render$2(ready, context);
    },
  };

  const render$3 = () => {};


  script$2.render = render$3;
  script$2.__file = "src/components/LMarker.vue";

  const props$4 = {
    ...props$2,
    pane: {
      type: String,
      default: "tilePane",
    },
    opacity: {
      type: Number,
      custom: false,
      default: 1.0,
    },
    zIndex: {
      type: Number,
      default: 1,
    },
    tileSize: {
      type: Number,
      default: 256,
    },
    noWrap: {
      type: Boolean,
      default: false,
    },
  };

  const setup$4 = (props, leafletRef) => {
    const { options: layerOptions, methods: layerMethods } = setup$2(
      props,
      leafletRef
    );
    const options = {
      ...layerOptions,
      pane: props.pane,
      opacity: props.opacity,
      zIndex: props.zIndex,
      tileSize: props.tileSize,
      noWrap: props.noWrap,
    };
    return { options, methods: { ...layerMethods } };
  };

  const props$5 = {
    ...props$4,
    tms: {
      type: Boolean,
      default: false,
    },
    subdomains: {
      type: String,
      default: "abc",
    },
    detectRetina: {
      type: Boolean,
      default: false,
    },
    url: {
      type: String,
      default: null,
    },
  };

  const setup$5 = (props, leafletRef) => {
    const {
      options: gridLayerOptions,
      methods: gridLayerMethods,
    } = setup$4(props, leafletRef);
    const options = {
      ...gridLayerOptions,
      tms: props.tms,
      subdomains: props.subdomains,
      detectRetina: props.detectRetina,
    };
    return {
      options,
      methods: {
        ...gridLayerMethods,
      },
    };
  };

  var script$3 = {
    props: props$5,
    setup(props, context) {
      const leafletRef = vue.ref({});

      const addLayer = vue.inject("addLayer");

      const { options, methods } = setup$5(props, leafletRef);

      vue.onMounted(async () => {
        const { tileLayer, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );
        leafletRef.value = tileLayer(props.url, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props, setOptions);
        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
      });
    },
    render() {
      return null;
    },
  };

  const render$4 = () => {};


  script$3.render = render$4;
  script$3.__file = "src/components/LTileLayer.vue";

  const props$6 = {
    iconUrl: {
      type: String,
      custom: true,
      default: null,
    },
    iconRetinaUrl: {
      type: String,
      custom: true,
      default: null,
    },
    iconSize: {
      type: [Object, Array],
      custom: true,
      default: null,
    },
    iconAnchor: {
      type: [Object, Array],
      custom: true,
      default: null,
    },
    popupAnchor: {
      type: [Object, Array],
      custom: true,
      default: () => [0, 0],
    },
    tooltipAnchor: {
      type: [Object, Array],
      custom: true,
      default: () => [0, 0],
    },
    shadowUrl: {
      type: String,
      custom: true,
      default: null,
    },
    shadowRetinaUrl: {
      type: String,
      custom: true,
      default: null,
    },
    shadowSize: {
      type: [Object, Array],
      custom: true,
      default: null,
    },
    shadowAnchor: {
      type: [Object, Array],
      custom: true,
      default: null,
    },
    bgPos: {
      type: [Object, Array],
      custom: true,
      default: () => [0, 0],
    },
    className: {
      type: String,
      custom: true,
      default: "",
    },
    options: {
      type: Object,
      custom: true,
      default: () => ({}),
    },
  };

  /**
   * Icon component, lets you add and custom icons to the map
   */
  var script$4 = {
    name: "LIcon",
    props: props$6,
    setup(props, context) {
      const root = vue.ref(null);

      const canSetParentHtml = vue.inject("canSetParentHtml");
      const setParentHtml = vue.inject("setParentHtml");
      const setIcon = vue.inject("setIcon");

      let onDomEvent;
      let offDomEvent;
      let divIcon;
      let icon;
      let iconObject = undefined;

      const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {
        const elHtml = el && el.innerHTML;
        if (!recreationNeeded) {
          if (htmlSwapNeeded && iconObject && canSetParentHtml()) {
            setParentHtml(elHtml);
          }
          return;
        }

        const listeners = remapEvents(context.attrs);
        if (iconObject) {
          offDomEvent(iconObject, listeners);
        }

        const options = {
          ...props,
        };

        if (elHtml) {
          options.html = elHtml;
        }

        iconObject = options.html ? divIcon(options) : icon(options);
        onDomEvent(iconObject, listeners);
        setIcon(iconObject);
      };

      const scheduleCreateIcon = () => {
        vue.nextTick(() => createIcon(root.value, true, false));
      };

      const scheduleHtmlSwap = () => {
        vue.nextTick(() => createIcon(root.value, false, true));
      };

      const methods = {
        setIconUrl: scheduleCreateIcon,
        setIconRetinaUrl: scheduleCreateIcon,
        setIconSize: scheduleCreateIcon,
        setIconAnchor: scheduleCreateIcon,
        setPopupAnchor: scheduleCreateIcon,
        setTooltipAnchor: scheduleCreateIcon,
        setShadowUrl: scheduleCreateIcon,
        setShadowRetinaUrl: scheduleCreateIcon,
        setShadowAnchor: scheduleCreateIcon,
        setBgPos: scheduleCreateIcon,
        setClassName: scheduleCreateIcon,
        setHtml: scheduleCreateIcon,
      };

      vue.onMounted(async () => {
        const { DomEvent, divIcon: lDivIcon, icon: lIcon } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        onDomEvent = DomEvent.on;
        offDomEvent = DomEvent.off;
        divIcon = lDivIcon;
        icon = lIcon;

        propsBinder(methods, {}, props);

        const observer = new MutationObserver(scheduleHtmlSwap);
        observer.observe(root.value, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true,
        });
        scheduleCreateIcon();
      });

      return () => {
        const content = context.slots.default
          ? context.slots.default()
          : undefined;

        return vue.h("div", { ref: root }, content);
      };
    },
  };

  const render$5 = () => {};


  script$4.render = render$5;
  script$4.__file = "src/components/LIcon.vue";

  const props$7 = {
    interactive: {
      type: Boolean,
      default: true,
    },
    bubblingMouseEvents: {
      type: Boolean,
      default: true,
    },
  };

  const setup$6 = (props) => {
    const options = {
      interactive: props.interactive,
      bubblingMouseEvents: props.bubblingMouseEvents,
    };

    const methods = {};

    return { options, methods };
  };

  const props$8 = {
    ...props$2,
    ...props$7,
    stroke: {
      type: Boolean,
      custom: true,
      default: true,
    },
    color: {
      type: String,
      custom: true,
      default: "#3388ff",
    },
    weight: {
      type: Number,
      custom: true,
      default: 3,
    },
    opacity: {
      type: Number,
      custom: true,
      default: 1.0,
    },
    lineCap: {
      type: String,
      custom: true,
      default: "round",
    },
    lineJoin: {
      type: String,
      custom: true,
      default: "round",
    },
    dashArray: {
      type: String,
      custom: true,
      default: null,
    },
    dashOffset: {
      type: String,
      custom: true,
      default: null,
    },
    fill: {
      type: Boolean,
      custom: true,
      default: false,
    },
    fillColor: {
      type: String,
      custom: true,
      default: "#3388ff",
    },
    fillOpacity: {
      type: Number,
      custom: true,
      default: 0.2,
    },
    fillRule: {
      type: String,
      custom: true,
      default: "evenodd",
    },
    className: {
      type: String,
      custom: true,
      default: null,
    },
  };

  const setup$7 = (props, leafletRef, context) => {
    const { options: layerOptions, methods: layerMethods } = setup$2(
      props,
      leafletRef,
      context
    );
    const {
      options: interactiveLayerOptions,
      methods: interactiveLayerMethods,
    } = setup$6(props);

    const removeLayer = vue.inject("removeLayer");

    const options = {
      ...layerOptions,
      ...interactiveLayerOptions,
      stroke: props.stroke,
      color: props.color,
      weight: props.weight,
      opacity: props.opacity,
      lineCap: props.lineCap,
      lineJoin: props.lineJoin,
      dashArray: props.dashArray,
      dashOffset: props.dashOffset,
      fill: props.fill,
      fillColor: props.fillColor,
      fillOpacity: props.fillOpacity,
      fillRule: props.fillRule,
      className: props.className,
    };
    const methods = {
      ...layerMethods,
      ...interactiveLayerMethods,
      setStroke(stroke) {
        leafletRef.value.setStyle({ stroke });
      },
      setColor(color) {
        leafletRef.value.setStyle({ color });
      },
      setWeight(weight) {
        leafletRef.value.setStyle({ weight });
      },
      setOpacity(opacity) {
        leafletRef.value.setStyle({ opacity });
      },
      setLineCap(lineCap) {
        leafletRef.value.setStyle({ lineCap });
      },
      setLineJoin(lineJoin) {
        leafletRef.value.setStyle({ lineJoin });
      },
      setDashArray(dashArray) {
        leafletRef.value.setStyle({ dashArray });
      },
      setDashOffset(dashOffset) {
        leafletRef.value.setStyle({ dashOffset });
      },
      setFill(fill) {
        leafletRef.value.setStyle({ fill });
      },
      setFillColor(fillColor) {
        leafletRef.value.setStyle({ fillColor });
      },
      setFillOpacity(fillOpacity) {
        leafletRef.value.setStyle({ fillOpacity });
      },
      setFillRule(fillRule) {
        leafletRef.value.setStyle({ fillRule });
      },
      setClassName(className) {
        leafletRef.value.setStyle({ className });
      },
    };

    vue.onBeforeUnmount(() => {
      removeLayer();
    });

    return { options, methods };
  };

  const props$9 = {
    ...props$8,
    latLngs: {
      type: Array,
      default: () => [],
    },
    smoothFactor: {
      type: Number,
      custom: true,
      default: 1.0,
    },
    noClip: {
      type: Boolean,
      custom: true,
      default: false,
    },
  };

  const setup$8 = (props, leafletRef, context) => {
    const { options: pathOptions, methods: pathMethods } = setup$7(
      props,
      leafletRef,
      context
    );
    const options = {
      ...pathOptions,
      ...props,
    };

    const methods = {
      ...pathMethods,
      setSmoothFactor(smoothFactor) {
        leafletRef.value.setStyle({ smoothFactor });
      },
      setNoClip(noClip) {
        leafletRef.value.setStyle({ noClip });
      },
      addLatLng(latLng) {
        leafletRef.value.addLatLng(latLng);
      },
    };
    return { options, methods };
  };

  /**
   * Polyline component, lets you add and personalize polylines on the map
   */
  var script$5 = {
    name: "LPolyline",
    props: props$9,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);

      const addLayer = vue.inject("addLayer");

      const { options, methods } = setup$8(props, leafletRef, context);

      vue.onMounted(async () => {
        const { polyline, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        leafletRef.value = polyline(props.latLngs, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props, setOptions);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
      });
      return render$2(ready, context);
    },
  };

  const render$6 = () => {};


  script$5.render = render$6;
  script$5.__file = "src/components/LPolyline.vue";

  const props$a = {
    content: {
      type: String,
      default: null,
    },
  };

  const setup$9 = (props, leafletRef) => {
    const options = {};
    const methods = {
      setContent(newVal) {
        if (leafletRef.value && newVal !== null && newVal !== undefined) {
          leafletRef.value.setContent(newVal);
        }
      },
    };
    return { options, methods };
  };

  const render$7 = (root, context) => () => {
    if (context.slots.default) {
      return vue.h("div", { ref: root }, context.slots.default());
    }
    return null;
  };

  const props$b = {
    ...props$a,
  };

  const setup$a = (props, leafletRef) => {
    const { options, methods } = setup$9(props, leafletRef);
    const unbindTooltip = vue.inject("unbindTooltip");

    vue.onBeforeUnmount(() => {
      unbindTooltip();
    });

    return { options, methods };
  };

  /**
   * Display a tooltip on the map
   */
  var script$6 = {
    name: "LTooltip",
    props: props$b,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const root = vue.ref(null);

      const bindTooltip = vue.inject("bindTooltip");
      const { options, methods } = setup$a(props, leafletRef);

      vue.onMounted(async () => {
        const { tooltip, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        leafletRef.value = tooltip(options);

        propsBinder(methods, leafletRef.value, props, setOptions);
        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);
        leafletRef.value.setContent(props.content || root.value);
        bindTooltip({ leafletObject: leafletRef.value });
      });
      return render$7(root, context);
    },
  };

  const render$8 = () => {};


  script$6.render = render$8;
  script$6.__file = "src/components/LTooltip.vue";

  const props$c = {
    ...props$a,
    latLng: {
      type: [Object, Array],
      default: () => [],
    },
  };

  const setup$b = (props, leafletRef) => {
    const { options, methods } = setup$9(props, leafletRef);
    const unbindPopup = vue.inject("unbindPopup");

    vue.onBeforeUnmount(() => {
      unbindPopup();
    });

    return { options, methods };
  };

  /**
   * Display a popup on the map
   */
  var script$7 = {
    name: "LPopup",
    props: props$c,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const root = vue.ref(null);

      const bindPopup = vue.inject("bindPopup");
      const { options, methods } = setup$b(props, leafletRef);

      vue.onMounted(async () => {
        const { popup, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        leafletRef.value = popup(options);

        if (props.latLng !== undefined) {
          leafletRef.value.setLatLng(props.latLng);
        }

        propsBinder(methods, leafletRef.value, props, setOptions);
        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);
        leafletRef.value.setContent(props.content || root.value);
        bindPopup({ leafletObject: leafletRef.value });
      });
      return render$7(root, context);
    },
  };

  const render$9 = () => {};


  script$7.render = render$9;
  script$7.__file = "src/components/LPopup.vue";

  const props$d = {
    ...props$9,
  };

  const setup$c = (props, leafletRef, context) => {
    const { options: polylineOptions, methods: polylineMethods } = setup$8(
      props,
      leafletRef,
      context
    );
    const options = {
      ...polylineOptions,
      ...props,
    };

    const methods = {
      ...polylineMethods,
      toGeoJSON(precision) {
        return leafletRef.value.toGeoJSON(precision);
      },
    };

    return { options, methods };
  };

  /**
   * Polygon component, lets you add and customize polygon regions on the map
   */
  var script$8 = {
    name: "LPolygon",
    props: props$d,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setup$c(props, leafletRef, context);

      vue.onMounted(async () => {
        const { polygon, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        leafletRef.value = polygon(props.latLngs, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props, setOptions);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
      });

      return render$2(ready, context);
    },
  };

  const render$a = () => {};


  script$8.render = render$a;
  script$8.__file = "src/components/LPolygon.vue";

  const props$e = {
    ...props$d,
    bounds: {
      type: Array,
      default: undefined,
    },
  };

  const setup$d = (props, leafletRef, context) => {
    const { options: polygonOptions, methods: polygonMethods } = setup$c(
      props,
      leafletRef,
      context
    );
    const options = {
      ...polygonOptions,
      ...props,
    };

    const methods = {
      ...polygonMethods,
      setBounds(latLngBounds) {
        leafletRef.value.setBounds(latLngBounds);
      },
      setLatLngs(latLngs) {
        // Calling setLatLngs on a Leaflet rectangle will convert it
        // to a polygon. So instead, we call setBounds here to ensure
        // that the rectangle remains a rectangle, defined by the
        // bounds of the points in the latLngs array.
        leafletRef.value.setBounds(latLngs);
      },
    };

    return { options, methods };
  };

  /**
   * Rectangle component, lets you add and customize rectangular regions on the map
   */
  var script$9 = {
    name: "LRectangle",
    props: props$e,
    setup(props, context) {
      const leafletRef = vue.ref({});
      const ready = vue.ref(false);
      const addLayer = vue.inject("addLayer");

      const { options, methods } = setup$d(props, leafletRef, context);

      vue.onMounted(async () => {
        const { rectangle, latLngBounds, DomEvent, setOptions } = await import(
          'leaflet/dist/leaflet-src.esm'
        );

        const bounds =
          props.bounds && props.bounds.length
            ? latLngBounds(props.bounds)
            : latLngBounds(props.latLngs);
        leafletRef.value = rectangle(bounds, options);

        const listeners = remapEvents(context.attrs);
        DomEvent.on(leafletRef.value, listeners);

        propsBinder(methods, leafletRef.value, props, setOptions);

        addLayer({
          ...props,
          ...methods,
          leafletObject: leafletRef.value,
        });
        ready.value = true;
      });

      return render$2(ready, context);
    },
  };

  const render$b = () => {};


  script$9.render = render$b;
  script$9.__file = "src/components/LRectangle.vue";

  exports.LControlLayers = script;
  exports.LIcon = script$4;
  exports.LMap = script$1;
  exports.LMarker = script$2;
  exports.LPolygon = script$8;
  exports.LPolyline = script$5;
  exports.LPopup = script$7;
  exports.LRectangle = script$9;
  exports.LTileLayer = script$3;
  exports.LTooltip = script$6;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=vue-leaflet.umd.js.map
